1:创建派生类对象的时候，程序先调用基类构造函数（初始化基类数据成员），再调用派生类构造函数。
派生类的构造函数总是调用一个基类构造函数。
《《可以使用初始化器列表指明要使用的基类构造函数》》。

 先调用派生类析构函数，在调用基类析构函数

2：派生类可以使用基类的方法（非私有）；
	基类指针可以在不显示类型转换情况下指向派生类。
	基类引用可以在不显示类型转换情况下引用派生类对象。  ---》只能调用基类方法
3：继承 is-a关系
4：多态： 派生类和基类中行为不同
    使用虚方法

    	派生类不能直接访问基类的私有数据，而是通过共有方法。
    	使用虚析构函数。
 5：静态联编：编译时候进行联编。
    动态联编： 虚函数--》确定用户使用的正确代码
    上强制转换： 派生类指针或引用转换为  基类指针或引用  --》导致不知道指向哪个方法，因此需要动态联编
    允许隐式向下强制转换
 6：虚成员函数和动态联编：
 	定义为虚函数，使用动态联编程。（采取方法跟踪基类指针或引用指向的对象）
 7：虚函数的工作原理：
 	给每个对象增加一个隐藏成员 ---》指向函数地址数组的指针 ---》虚函数表
 		-》存储了为类对象进行声明的虚函数的地址（数组，存储了虚函数地址）

 		根据对象，访问虚函数表的地址，根据地址，执行对应的虚函数。

 		基类：存储虚函数的地址
 		派生类：存储派生类虚函数的地址，如果重新实现，就更该基类原来的地址。


 8：对象增大，增大了存储地址的空间
    每个类，编译器创建一个虚函数地址表（数组）
    每次函数调用，多了一步检查，表中查找地址

 9：构造函数 析构函数 友元函数不能是虚函数
 10：protected
      派生类中的成员可以直接访问protected类成员
 11：ABC理念：抽象继承  只定义接口，不定义实现
 12：void Star::show() const{}  const确保不会修改它的对象  即， const Star× *this;
 13: 派生类如果按值传递给基类类型的参数，因为复制构造会使其转为基类。--》自动向上强制转换


 练习：
 1：基类与派生类练习；
 2：多态公有继承练习（虚函数）
 3：动态联编虚函数列表源代码理解
 4：ABC理论抽象继承练习
 5：使用动态分配和友元的继承的练习


 复习题：
 1：基类的共有成员成为派生类的共有成员。
    基类的保护成员成为派生类的保护成员。
    基类的私有成员不能直接被访问。
 2：构造函数，析构函数，赋值运算符和有友元
 3：返回void 不能连续赋值
    返回引用而不是对象，降低效率
 4：创建派生类  先执行基类构造函数，在执行派生类构造函数。
    删除派生类  先执行派生类析构函数，在执行基类析构函数
 5：需要，析构函数无法被继承，必须存在，可以为空
 6：只调用派生类的。 应当把重新定义的函数声明为虚函数
 7：new 或者new[]动态申请内存时
 8：可以 可以，但是不安全（显示转换）
 9：可以 重定义=才可以
 10：向上强制类型转换
 11：复制构造函数，新的一个对象，基类的
 12：引用传递  --》虚函数受益
             --》节省空间和效率，大型对象
             --》const保证
     按值传递 --》保护源数据
 13：常规函数：执行基类对应的方法
     虚函数：执行派生类对应的方法
 14：不是is-a模型，不适合继承
    虚函数更改了函数特征。