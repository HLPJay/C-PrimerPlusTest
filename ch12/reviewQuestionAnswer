1: 默认构造函数
2: 复制构造函数 StringBad(const string &)
		在构造函数中new对象涉及复制构造函数问题，会多次释放，析构函数计数就会有问题
		已经释放的内存继续被指向，会有乱码的问题
		--》用显示复制构造函数处理
3：赋值运算符  Stringbad & Stringbad::operator =(const stringBad &);
4: str = new char[1] 与new char相同  但是与delete[] str;兼容
5：str = 0；  C++11中string的定义？ 用的new char[1]?
6: 防止隐士转换 explicit
7"： 转换函数  operator int（）；
8: 使用对象指针：
	1：指针初始化指向已有的对象
	2：使用new通过构造函数初始化
9：通过定位new运算符做处理时 删除用delete[]buffer;
10：构造函数初始化列表
    如果有const成员变量（常量，构造时初始化）， 则构造函数内的代码块不允许重新赋值的，需要在构造函数初始化列表中去进行初始化。

    必须用来初始化非静态的数据成员
    必须用来初始化引用数据成员
    C++11允许在类内声明时直接初始化
练习：
1：string对象的实现


复习题：
1：没有将str指针初始化，应该使用指针初始化为null或者用new[]初始化
   使用了原始字符串（同一个地址），应该使用new或者strcpy
   没有申请内存，new[len+1]
2: a:应该在析构函数中删除
   b:注意复制和赋值时，导致的多次析构
3：默认构造函数， 复制构造函数，赋值构造函数，析构函数 地址运算符
		默认生成的函数只是做声明，不做处理
		隐式地址符只返回this指针
4：a：类的默认访问是私有的，成员函数应该设置为public；
	 重载<<应该使用友元函数  friend，其参数也应该定义为const
	 构造函数的参数应该定义为const
5：需要一个赋值运算符重载的赋值构造函数